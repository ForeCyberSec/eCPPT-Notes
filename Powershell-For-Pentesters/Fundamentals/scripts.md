


Scripts are another element of our leveraging of PowerShell as an offensive tool, and most of the
time, this is probably the most common way we will utilize PowerShell for most tasks


PowerShell Scripts are usually identified by the .ps1 extension, the 1 indicating not the version 
of PowerShell but rather the PowerShell engine

For the most part, we will be dealing with the .ps1 file



PowerShell scripts can contain as little as a few commands to automate some tasks or be as complex 
as to contain parameters, script arguments, loops, functions and anything else related to the 
capabilities that PowerShell offers as a scripting language 


Running a PowerShell script is as simple as calling it from the PowerShell console, using the 
(dot-backslash notation) .\ for a script in our current directory

PS C:\> .\example.ps1


# Script Example

A very basic example of a PowerShell script which takes a file name as an argument would be 
something like the following



Param{
	[parameter(mandatory=$true)][string]$file
}
Get-Content "$file"


The above script simply takes a file name as an argument for which it creates a variable called 
$file and runs the Get-Content cmdlet on our variable


Therefore when we run the script filewith a file as an argument


.\example.ps1 users.txt


It will show the content of that file in the PowerShell console


If we run the script without arguments, PowerShell will ask us for the file, since "mandatory=$true"
has been set for the parameter function in our script


Alternatively, we could also just create a variable for our users.txt file and then call the
Get-Content script against our variable, directly from the shell as shown below


PS C:\> $file="users.txt"
PS C:\> Get-Content $file





# PowerShell Loop Statements 

PowerShell supports several loops which we can utilize for different tasks

As we saw with a previous example of the ForEach-Object cmdlet, we can use loop statements to 
iterate through files, PowerShell object collections, and even conduct port scans


for()

foreach()

while()

do {something} while()

do {something} until()




We can get help on any of these statements with the Get-Help cmdlet

PS C:\> Get-Help about_Foreach

PS C:\> Get-Help about_For

PS C:\> Get-Help about_Do

PS C:\> Get-Help about_While



Loops are generally divided into two parts, a loop statement, and a loop body and will also
contain variables as seen below

$services = Get-Service
foreach ($service in $services) { $service.name } 


In the first line, we're creating a variable called "$services" which will return the Get-Service
Objects collection as a result of running the Get-Service cmdlet 

We then use the foreach() loop statement to create a new variable "$service" to contain each 
resulting object of the $services variable, and finally, we're telling PowerShell to return the 
name of each $service with the .Name property in the loop body, between the {} braces





Furthermore, we can use several built in cmdlets for constructing loops, specifically the 
ForEach-Object and Where-Object cmdlets 

The previous example could be similarly accomplished by using the Get-Service and ForEach-Object
cmdlets and pipeline as follows


//the space is before .name so sublime doesnt throw an error, remove this to run the cmd
PS C:\> Get-Service | ForEach-Object {$_ .Name } 

 

The WHere-Object cmdlet allows us to select objects within a collection based on their property
values in regard to when used for a loop. In the following example, we're using the Get-ChildItem
cmdlet to list the contents of a PowerShell directory, while piping that output to the
Where-Object cmdlet with the -match parameter to only return files that contain "xls" within 
their name



//the space is before .name so sublime doesnt throw an error, remove this to run the cmd
PS C:\> Get-ChildItem C:\PowerShell\ | Where-Object {$_ .name -match "xls"}


# PowerShell TCP portscanner oneliner screenshot  example shown in folder


You could also put the portscanner script into a file and run it like

PS C:\> .\Scan-ports.ps1

