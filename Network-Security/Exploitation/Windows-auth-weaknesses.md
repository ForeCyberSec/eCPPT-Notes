

# Windows Authentication Weakness Notes



# NTLM (NT LAN Manager)

Although NTLM has been replaced by Kereberos, it is still widely used and supported in Windows machines.
For example, it is used either when the client is authenticating to a server using an IP address or, 
when the client is authenticating to a server that does not belong to the same domain


In order to understand future NTLM attacks explained, we first have to understand how NTLM works


NTLM authentication is a challenge/response protocol and consists of three messages:

Type 1 (negotiation)

Type 2 (challenge)

Type 3 (authentication)


The whole challenge/response works like this:

1. The client sends the Type 1 message, which contains the username (in plaintext)

2. The server generates the challenge and sends it back to the client

3. The client encrypts the challenge with the hash of the user password and returns the results
of the computation to the server


The actual password is never sent on the network since it is hashed and encrypted. The schemes
used to encrypt and send the Type 3 response have changed over the years due to lack of security.

The very first scheme was LM, which turned out to be very simple to crack. As a result, it was replaced by
NTLM, which in turn was replaced by NTLMv2 and finally Kerberos at the end


Notice that recent Windows operating systems might still store LM hashes for backward compatability and
send them with the NTLM protocol

Now that we know a bit more about how the authentication process works, let us dive into how the responses
(Type 3) are generated and why they are so weak


# LM hash 

The algoritm used to compute the LM Hash is DES and here are the steps used by Windows to do so:


Password is transformed to uppercase 

Add null chars until it is 14 bytes long

Split the password in two blocks (7 byte chunks plus a byte of parity)

Each of the two keys is used to encrypt the fixed string "KGS!@#$%" (8 byte ciphertext)

The two ciphertexts are concatenated to form a 16-byte value


# NTLM 

The computation of NTLM hashes is still very simple: 

The user's password is converted to UNICODE

MD4 is then used to get a 16-byte long hash


By using UNICODE, the allowd charset is much wider. Although it addresses some LM flaws, it is still 
considered weak. Moreover, the NTLM response is sent together with the LM response, most of the time



# Protocol recep

The two protocols work as follows: 

1. The client send a request for authentication

2. Server sends an 8-byte challenge (random valuel)

3. Client encrypts the challenge using the password hash and sends it back as a response



The goal of our attack is to gain the password hash through the implementation of
this protocol

During the attack we will impersonate the server. Notive that the most important part
of the protocol is step 3, where the client hash resides


So lets see how this message is built by the client and sent to us (the server)


The generated hash (16-bytes long) is padded with 5 null bytes making it a 21 byte string

# important
This is called NTLM hash, that is different from the NT hash


This 21 byte string is split in 3 blocks, 7 bytes long each + 1 parity byte. The response 
will then be 24 bytes long


Each of these blocks will be the key to encrypt the Server challenge sent during message 2

Note that in the attack scenario we impersonate the server, therefore the challenge is chosen by us

NTLM Hash computation example image in folder


Now that we know how LM and NTLMv1 authentication protocols work, we can move on and see how, as a 
penetration tester, we can exploit their weaknesses

# LM/NTLM Protocol Weaknesses

To conduct a successful attack, we must first understand the weaknesses of the protocols:

No diffusion, meaning that each part of DES output is not linked to the previous one. This allows 
attacks on the three blocks individually

DES is an old algorithm with intrinsic weaknesses. The third DES key is much weaker than the others,
since it has 5 null bytes for padding

The only randomness in the protocol is the server challenge (step 3 of the protocol) Again, 
we impersonate the server so we control that


# NTLM Protocol

Note on our SMB server we created, when the target machine sent an authentication request to us,
the LM hash and NT hash were different, indicating that LM is in use. If both of the hashes are 
the same, it would mean only NT hashes are in use on the remote client


It is also useful to note that when the password length is less than or equal to seven chars, the
last 8 bytes of the NTLM response is always the same on the LM hash


# NTLMv2 (started with windows vista)

The main difference with the old NTLMv1 is that the type 3 message is generated in a different way. 
Once again the Type 3 message (step 3 of the protocol) is the most important part of the protocol



The Type 3 message is where the protocol security resides. The NTLMv2 response is built as 
follows:

NTLMv2 hash: 
contains the HMAC-MD5 of the NT hash and the pair <USERNAME,server> (note here that
username is uppercase and Server is case sensitive)

NTLMv2 response: 
contains the HMAC-MD5(NTLMv2 Hash, <BLOB,Server_challenge>), sent along with the BLOB
	(server recieves hash + blob)
	Note that the BLOB contains a client challenge and the timestamp


Here is how the BLOB is built:

BLOB signature (4 bytes)
Reserved (4 bytes)
Timestamp (8 bytes)
Client nonce (random 8 bytes)
Unknown (4 bytes)
Target Information (Variable length)
Unkown (4 bytes)


if we looked at an example of NTLMv2 responses with timestamps, we would see that that the response
hash and challenge are different every time


Under the security perspective, NTLMv2 changes are as follows: Due to timestamp and the client
client response, the response changes every time

Impossible to create rainbow tables to gather the NT hash or the password from the NTLMv2
response

Dictionary does not make sense as the key is a hash

The only possible attack is by brute forcing the HMAC key

The NTLMv2 hash is bound to a particular server and particular username so its not reusable


Although cracking NTLMv2 is considered infeasible (if the password is strong enough), we can still
use the hash to mount different attacks




# SMB Relay attacks


SMB Relay attacks allow the attacker to re-use authentication attempts in order to gain access to a
system in the network


The SMB Relay attack borrows the name from the tool released back in 2001 by Sir Dystic, called
SMBRelay

Although both the tool and the exploit worked well for that time, Microsoft partially fixed this
vulernability seven years later. After 14 years, at Black Hat USE 2015, two researcher demonstrated
how the vulerability can still be exploited


# Attack Overview

During an SMB Relay attack, the attacker acts like a man in the middle:

The attacker selects the target and waits until someone in the network tries to
authenticate to his machine

When a machine tries to authenticate on the attacker, it sends the authentication attempt
to the selected target

The target creates the challenge and sends it back to the attacker

The attacker sends the challenge to the machine that initiated the connection

The machine encrypts the challenge with the password hash and sends it back to the attacker

The attacker sends the encrypted challenge to the target and authenticates itself


Also this this will only work if the target machine has the "Network security: LAN Manager
authentication level" set to "SEND LM & NTLM responses"



# The metasploit module for this attack is smb_relay




# Eternal Blue (MS17-010)

In 2017, one of the more impactful exploits affecting SMB was exposed by a hacker group known 
as the  "Shadow Brokers" and was known as "EternalBlue", one tool amond many purportedly created by
the Equation Group


Eternal Blue was also known to have helped carry out the "NotPatya" cyber attack and was also found
to have been used in various Banking trojans such as "Retefe" that same year


The vulnerability affected Microsoft's SMBv1 implementation and was also given CVE_ID 
(CVE-2017-0144) and a critical security bullletin was also released by microsoft as 
MS17-010

The Vulnerability arises due to the way that the SMBv1 server handles specially crafted packets of
which, ultimatey results in remote code execution as the NT AUTHORITY\SYSTEM user when exploited




There are metasploit modules specifically for detecting this vulnerability



