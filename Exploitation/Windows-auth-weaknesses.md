

# Windows Authentication Weakness Notes



# NTLM (NT LAN Manager)

Although NTLM has been replaced by Kereberos, it is still widely used and supported in Windows machines.
For example, it is used either when the client is authenticating to a server using an IP address or, 
when the client is authenticating to a server that does not belong to the same domain


In order to understand future NTLM attacks explained, we first have to understand how NTLM works


NTLM authentication is a challenge/response protocol and consists of three messages:

Type 1 (negotiation)

Type 2 (challenge)

Type 3 (authentication)


The whole challenge/response works like this:

1. The client sends the Type 1 message, which contains the username (in plaintext)

2. The server generates the challenge and sends it back to the client

3. The client encrypts the challenge with the hash of the user password and returns the results
of the computation to the server


The actual password is never sent on the network since it is hashed and encrypted. The schemes
used to encrypt and send the Type 3 response have changed over the years due to lack of security.

The very first scheme was LM, which turned out to be very simple to crack. As a result, it was replaced by
NTLM, which in turn was replaced by NTLMv2 and finally Kerberos at the end


Notice that recent Windows operating systems might still store LM hashes for backward compatability and
send them with the NTLM protocol

Now that we know a bit more about how the authentication process works, let us dive into how the responses
(Type 3) are generated and why they are so weak


# LM hash 

The algoritm used to compute the LM Hash is DES and here are the steps used by Windows to do so:


Password is transformed to uppercase 

Add null chars until it is 14 bytes long

Split the password in two blocks (7 byte chunks plus a byte of parity)

Each of the two keys is used to encrypt the fixed string "KGS!@#$%" (8 byte ciphertext)

The two ciphertexts are concatenated to form a 16-byte value


# NTLM 

The computation of NTLM hashes is still very simple: 

The user's password is converted to UNICODE

MD4 is then used to get a 16-byte long hash


By using UNICODE, the allowd charset is much wider. Although it addresses some LM flaws, it is still 
considered weak. Moreover, the NTLM response is sent together with the LM response, most of the time



# Protocol recep

The two protocols work as follows: 

1. The client send a request for authentication

2. Server sends an 8-byte challenge (random valuel)

3. Client encrypts the challenge using the password hash and sends it back as a response



The goal of our attack is to gain the password hash through the implementation of
this protocol

During the attack we will impersonate the server. Notive that the most important part
of the protocol is step 3, where the client hash resides


So lets see how this message is built by the client and sent to us (the server)


The generated hash (16-bytes long) is padded with 5 null bytes making it a 21 byte string

# important
This is called NTLM hash, that is different from the NT hash


This 21 byte string is split in 3 blocks, 7 bytes long each + 1 parity byte. The response 
will then be 24 bytes long


Each of these blocks will be the key to encrypt the Server challenge sent during message 2

Note that in the attack scenario we impersonate the server, therefore the challenge is chosen by us

NTLM Hash computation example image in folder


Now that we know how LM and NTLMv1 authentication protocols work, we can move on and see how, as a 
penetration tester, we can exploit their weaknesses

# LM/NTLM Protocol Weaknesses

To conduct a successful attack, we must first understand the weaknesses of the protocols:

No diffusion, meaning that each part of DES output is not linked to the previous one. This allows 
attacks on the three blocks individually

DES is an old algorithm with intrinsic weaknesses. The third DES key is much weaker than the others,
since it has 5 null bytes for padding

The only randomness in the protocol is the server challenge (step 3 of the protocol) Again, 
we impersonate the server so we control that

