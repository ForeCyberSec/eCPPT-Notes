


cmdlets are a big part of how we will leverage PowerShell for our offensive security purposes, two
of which we've already briefly covered: 

Get-Help
Get-Command




# What Are Cmdlets


Lets first generally summarize what cmdlets are

Light-weight PowerShell scripts that perform a single function (Can be as small as a few
lines of code) 

Instances of .NET Framework classes derived from the CMdlet Base Class and provide access to system
functions

Cmdlets are native commands in PowerShell (We can also create our own)

Typically written in a "Verb-Noun" file name format which helps us determine their function 
(e.g. Invoke-Command)

Typically used to return output to other cmdlets to then be processed via a pipeline (|)


Every cmdlet has its own set of parameters which can be discovered through the Get-Help cmdlet
as we've seen previously


It should be noted that most cmdlets, by default, when run without other parameters will 
return a limited set of information or "columns"


For Example, just running the Get-ChildItem cmdlet without any other arguments or options, returns 
four columns named "Mode", "LastWriteTime", "Length" and "Name"


But by piping the output of a cmdlet to the "Format-List" cmdlet, rather than columns and names as
seen in the previous slide, we can return all named properties associated with its objects in a 
different list-like format


PS C:\> Get-ChildItemm | Format-List *


These names wether in list format or the default column format are important, as we can use those
to filter the output of cmdlet objects for specific properties, as we'll see shortly


The results of all cmdlet output, are usually referred to as "objects"

These objects can be further processed using what is known as "pipelining", similiar to how we can 
chain commands together in a Linux bash shell for instance with the Pipe Operator (|) 



An example of this processing of cmdlet output objects with pipelines would be something like the
following:


PS C:\> Get-Process | Sort-Object -Unique | Select-Object ProcessName


The above returns a list of processes (Get-Process), then sorts the list (Sort-Object) with the
(-Unique) parameter, and finally, selects the "ProcessName" objects (Select-Object ProcessName)
and returns a unique list of process names



We can also redirect the results of our pipeline operation to a file using a standard Redirect
Operator (>) example shown below


PS C:\> Get-Process | Sort-Object -Unique | Select-Object ProcessName > uniq_procs.txt




# Lets now examine several examples of cmdlet usage we'll find useful for our work


The Get-Process cmdlet will give us a listing of all processes


Running the Get-Process cmdlet without any arguments returns a basic information as we can see,
and is formatted in a table-like format, which includes column names and (properties)


To get all of the information (properties) associated with all of the processes, we can pipe it
to the "Format-List * " cmdlet and wildcard argument

This will give us a better idea of how we can filter the data for specific properties


PS C:\> Get-Process | Format-List * 



We can further extend this to get information about specific processes and paths to their
executables (in this example, chrome and firefox), by using the "Format-List" cmdlet and also
specifying the "Path" property name


PS C:\> Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path


This will return paths for both chrome and firefox 


We can also append multiple property names to the Format-List cmdlet, and obtain the processes
Paths, and associated PID's (id) for instance


PS C:\> Get-Process chrome, firefox | Sort-Object -Unique | Format-List Path, Id


This will return the Path and Process ID



# Aliases

Another thing to know is that most cmdlets have aliases, for example, the alias of Get-ChildItem
is the ls command

This means both ls and Get-ChildItem will return the same results


To find out what the aliases are for a specfic cmdlet, we can use the Get-Alias cmdlet with the
-Definition parameter followed by a cmdlet name like the following command


PS C:\> Get-Alias -Definition Get-ChildItem


If we could see the output it would show that Get-ChildItem has 3 aliases, "dir", "gci" and "ls"



Another alias we will see often is "select" when used in conjunction with other cmdlets in pipline
operations and is an alias for the Select-Object cmdlet

In this example, we're using the Get-WmiObject cmdlet (used to return info about WMI objects) in 
conjunction with the "-class win32_operatingsystem" parameter and arguments, and then selecting 
(select) all ( * ) properties related to that WMI object class; this returns all information 
related to the current OS 


PS C:\> Get-WmiObject -class win32_operatingsystem | select -property *



ALternatively we could use the Format-List alias "ls" with the wildcard argument, and obtain the
same list of all properties for the WMI Ibject


PS C:\> Get-WmiObject -class win32_operatingsystem | fl *


We can use the Get-WmiObject cmdlet to obtain information regarding any WMI class, for instance,
getting a detailed list of properties for all services with the "win32_service" class


PS C:\> Get-WmiObject -class win32_service | fl *


And we can further extend our pipeline and filtering operation just to give us "PathName" which 
includes command line arguments and paths to all service executables


PS C:\> Get-WmiObject -class win32_service | Sort-Object -Unique PathName | fl PathName


And of course, saving the info we are gathering to a file is important as well. We can 
either redirect the output of the pipline operation to a file with the (>) redirect operator as 
we saw earlier, or sometimes we may need the results in a different format for processing

For this we can pipe all of the output to the Export-Csv cmdlet, and save the results 
in CSV format


PS C:\> Get-WmiObject -class win32_operatingsystem | fl * | Export-Csv C:\host_info.csv


# Exploring the Registry

For access to Windows Registry hives, PowerShell provides a convenient method with the following 
command: 

PS C:\> cd HKLM:\


We can easily navigate into areas we might be interested in with "cd" which is the alias for
"Set-Location", and furthermore, list the contents of our current hive with cmdlet Get-ChildItem 
or ls as shown below

PS HKLM:\> cd .\SOFTWARE\Microsoft\Windows\CurrentVersion\

PS HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\> ls



# Select-String


The Select-String cmdlet along with the -Path and -Pattern arguments is yet another useful 
PowerShell command we can use to scour the system for files containing certain strings

In the example below, we search for files of a .txt extension within a users Documents 
directory, containing the string "pass* " in their contents


PS C:\> Select-String -Path C:\user\Documents\*.txt -Pattern pass* 


# Get-Content


We can then use the Get-Content cmdlet to display the full contents of the passwords.txt
file


PS C:\> Get-Content C:\Users\User\Documents\passwords.txt




Alternatively, we can obtain the same results by using the Get-ChildItem cmdlet alias with 
the recurse parameter (ls -r) which lists files within a directory recursively, then, search 
for file types of .txt with the -File parameter. We'll then pipe that to the ForEach-Object
alias which is % and a script block {} that searches for the string "pass* " in all files in the
path specified with the alias for the Select-String cmdlet (sls) 


//also ignore the 2nd asterisk in this command it is just to close the MD italics in this doc

PS C:\> ls -r C:\users\user\Documents -File *.txt* | % {sls -Path $_ -Pattern pass* }


We will learn more about the ForEach-Object cmdlet later 



# Get-Service


The Get-Service cmdlet will get us information regarding currently installed services and can be
useful since we can identify a service which might be vulnerable to a privilege escalation
exploit


Running it without parameters or arguments will return a three column list of all services


We can extend those results, as we've seen before, with the Sort-Object cmdlet. In this example,
all services starting with s* in descending order and sorting by the Status property



//Do not put a space after s* this is just for the md italics here in this doc

PS C:\> Get-Service "s* " | Sort-Object Status -Descending




As we can see, there are many ways and variations of using cmdlets, pipelines, and aliases 
we can leverage to conduct tasks that are relevant to our objectives, and different ways to
craft commands we can use to achieve similiar results




# Refrences 



Cmdlet CLass
 https://msdn.microsoft.com/en-us/library/system.management.automation.cmdlet(v=vs.85).aspx


Cmdlets

https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7


LinEnum

https://github.com/rebootuser/LinEnum


.NET Framework Class Library

https://msdn.microsoft.com/en-us/library/gg145045(v=vs.110).aspx


Understanding the PowerShell pipeline 

https://www.petri.com/understanding-the-powershell-pipeline


Windows Powershell: The Many Ways to a Custom Object

https://technet.microsoft.com/en-us/library/hh750381.aspx




