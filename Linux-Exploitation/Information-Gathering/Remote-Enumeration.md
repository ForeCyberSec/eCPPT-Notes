

# Enumerating NFS


Please note that since NFS is an RPC-based service and relies on other RPC services, such as 
"mountd", it should be directly queried via the Portmapper service which is found on port TCP
and/or UDP 111 when using nmap NSE scripts for instance 

We'll cover Portmapper services shortly

An administrator wishing to share files from an NFS server will configure what are known as 
"exports". Exports are the mechanism used by NFS in order to "export" directories, in other 
words, make entire directories available to other users over the network 

Exports configured for any given NFS server can usually be found in the "etc/exports" file on a
target host locally. For now, we're going to focus on identifying available exports from a remote 
perspective 

One common issue with NFS, is that administrators will usually "export" directories with little
attention to security, and will usually export directories in a manner that allows any host 
or IP to connect, without any authentication, and if we're lucky, also provide write-access to
directories

Once we've identified that a server is running NFS, the first thing we want to do is query it 
with several nmap NSE scripts. Specifically, "nfs-ls", "nfs-showmount" and "nfs-statfs"

We can find some NSE scripts we can use for NFS with a simple command: 

## ls usr/share/nmap/scripts/ | grep nfs



We can then use a command similar to the following to obtain results relevant to NFS: 

## nmap --script nfs-ls,nfs-showmount,nfs-statfs <targetIP>


Example return output from the above command shown in folder


Alternatively we can use the built in "showmount" command with the -e or --exports switches 
to show any exports that would be available to us as well 

However, we can see it wont return as much information as the previous nmap command, as its 
designed to simply list any available exports: 

## showmount -e <targetIP> 



In the previous two examples, we can see that our tools identified two exported directories,
followed by a "*" value, which allows mounting the exports from any IP address or host. This 
configuration is often catastrophic

Ideally an admin would want to explicitly define (whitelist) IP addresses or hosts that should 
be allowed to connect to the NFS server, in which case, the output would be something similar to: 

Export list for <IP>: 
var/www admin.foocampus.com 192.168.13.100  <--- Whitelisted IP 
/home/bob 192.168.13.129                    <--- Adresses/Hosts


Even in the case that our access is restricted due to an NFS whitelist config like shown above, 
the output would still give us valuable information regarding which IP addresses or hosts can 
mount any available exports

In this scenario, that information would be useful in the case we can either spoof our IP address to
match a whitelisted IP address or take control of a host which is allowed to connect


Once we've gathered the relevant information and have confirmed a misconfiguration, we can attempt
to mount the available exported directories; this can be accomplished by first creating a temporary
directory as your mount point: 

## mkdir -p /mnt/home/bob

Then the exported NFS directory can be mounted with the following command: 

## mount -t nfs <NFS server IP>:/home/bob /mnt/home/bob - nolock

We can confirm that the previous commands were successful by viewing our currently mounted file 
systems and confirming that our NFS mount exists by just running the "mount" command without any 
arguments (example shown in folder)


We can then change into our /mnt/home/bob directory and list its contents and interact with it as 
if its another mounted partition on our operating system

## cd /mnt/home/bob && ls -al



# Enumerating Portmapper (rpcbind)

Portmapper (rpcbind) is another common service found on Linux-based systems and is used to esentially
"map" RPC (Open Network Computing Remote Procedure Call) or "ONC RPC", not to be confused with 
Microsoft's implementation of rpc) services to their corresponding TCP or UDP ports on a target system


Information gleaned from the portmap service can offer insight regarding ports that are listening
on a machine, but that may not necessarily be accessible over the network

As an example, a target system may be running a custom RPC service that is only accessible from 
the local host or may be running NFS, but only accessible from the local network, etc.

Kowing this information can give us insight as to local services that may be running which could 
help us in further exploiting a system if and when local access has been obtained 

Portmapper is typcially found listening on ports TCP/UDP 111 and in some cases, ports TCP/UDP 32771, 
and can be enumerated using nmap NSE scripts as show previously, or by using the built in "rpcinfo" 
command


We will see shortly that querying the portmapper service on TCP port 111, gives us an idea of other 
RPC-based services and ports that a system might have open, either remotely or locally

You can think of it as a static "port map" for RPC-based ports/services 

Querying a single port (tcp/111), essentially enumerates all related RPC service ports without 
us having to  conduct a port scan against all those ports individually

Furthermore, it gives us knowledge of which ports the system has open locally (bound to localhost),
which we couldnt normally identify with a usual port scan


Nmap's "rpcifno" and "rpc-grind" NSE scripts can be used to enumerate the Portmapper and 
associated services: 

## nmap --script rpc-grind,rpcinfo <targetIP> -p 111


The stand-alone "rpcinfo" command can give us similar results

rpcinfo -p <targetIP> 


Later we'll see how we can use a "xinetd" RPC-based UDP service combined with a netcat reverse shell, 
and a "port-knocking" method for persistence on a host once we have access

# SMB (Samba) 

Samba, a Linux-based implementation of the SMB/CIFS protocols, provides print and file sharing
services for windows clients within an environment. Recent versions also seamlessly can be integrated
with Active Directory domains 


Samba can offer us a great bit of information when enumerated properly. Depending on the 
configuration, we can obtain OS version, user accounts on the system, file shares, their permissions 
and potentially sensitive data, and, depending on its integration with Active Directory, can be used 
to enumerate much more information 

Improperly comfigured Samba servers can also lead to remote code execution amond other things, as
we'll see in later sections 

Samba can be found listening on the usual NetBIOS ports (137,138,139,445) '

Samba can be trivially identified wiuth a version scan (-sV) against NetBIOS ports


Now that we've identified that samba is on the target system, we can begin enumerating it for 
various information, including shares, users, password policies etc. 

For this we'll start with our trusted nmap NSE scripts, related to enumerating SMB

There are several SMB-related NSE scripts we can use, but we'll start with "smb-enum-shares"
to get an idea of shares that are available 

## nmap --script smb-enum-shares <targetIP>

From the output, there are several things we can confirm about the system: 

-Samba Version and OS
-Shares
-Anonymous/Guest Access is allowed 
-Access Rights for shares

Alternatively we can use "smbclient" with the "-L" switch and IP address to obtain similar information
about shares as well, including WORKGROUP and NetBIOS name

Simply hitting enter at the authentication prompt and obtaining results, also confirms that anonymous
or guest access to the Samba server is enabled: 

## SMBclient -L <targetIP>

In addition to simply listing shares which we have access to, we also want to know what type of access
we have to which shares, we can use smbmap for this purpose

## smbmap -H <targetIP> 

There are many other options available to us with smbmap, including interacting with the remote 
file system, searching file contents for specific strings, and even executing commands 

Once we've identified shares, we have several options for interacting with them. Once again, smbclient
can be used, but this time, we'll specify a host with the command as follows: 

smbclient \\\\<targetIP>\\sharenamegoeshere

We can then hit enter on the password prompt because we've already confirmed that the share allows
guest or anonymous access. If all goes well, we should then be presented with an "smb: \>" shell 
prompt

typing help in the smb shell will provide us with some helpful options. The two most used for our 
purposes are the get and put commands, which we'll see later


Another method we can use to mount smb shares is by using "mount"; this is similar to how we did 
with the NFS shares but will require the "cifs-utilis" package in this case. cifs-utils can 
be installed by issuing an "apt install cifs-utils" command from our shell (assuming youre on a debian based distribution). Once the cifs-utils are installed, we can use commands like the following to mount
the samba share: 

1. Create a local mount point with:
mkdir /mnt/www 

2. Mount the share
mount -t cifs \\\\<targetIP>\\www /mnt/www

3. then simply browse to your mount directory to access it
cd /mnt/www && ls -als



# SMB Users

Now that we've enumerated shares, a next step is to enumerate users over the SMB protocol

Enumerating users when it comes to Samba or over SMB can be accomplished in several wways. The first 
method we'll go over is a manual method using "rpcclient", and we'll also briefly cover a great
tool that can automate the information gathering process for Samba or any other SMB-based 
sercie, wether its on Linux or Windows 


## Method 1: Bash "for loop" and rpcclient

using rpcclient and a list of potential usernames we've gathered from other phases of information 
gathering, we can concoct a simple one-liner for loop in bash with rpcclient to enumerate the 
Samba server for users 

For instance, we know that "root" is likely a user considering the OS; so that name will go in 
our users.txt file. We also know that "bob" is a user since we saw his home directory during the 
NFS enumeration, so we'll include his name in the list as well, and so on

You may also want to check out the "Statistically-likely-usernames" github to help create a user
list consisting of probable usernames 

Once we've generated our list of potential usernames, we can feed that to rpcclient with the 
"lookupnames" option in the format of a bash for loop (screenshot example shown in folder)


There are several options available with rpcclient. Some useful rpcclient commands include 
"lookupsids", "netshareenum", "srvinfo" and "enumprivs" to mention several


## Method 2: Automated (enum4linux) 

A great tool we can use to enumerate an SMB server automatically is enum4linux by Porticullis Labs

It can be used to enumerate the following: 

-Operating System
-Users
-Password Policies
-Group Membership
-Shares
-Domain/Workgroup Identification

Example output from the following command can be seen in a screenshot in the folder: 

enum4linux <targetIP>




# Enumerating SMTP Users

This next section covers user enumeration through SMTP servers using enabled "verbs" or options 
that are enabled on a mail server

You're probably familiar with the "HELO", "RCPT" or "MAIL" verbs if you've ever sent an email 
while directly connected to an email server via telnet or some other way; (telnet mail.server.site 25)
for instance 

The following information does apply for both Windows and Linux-based mail servers since "SMTP" 
is the underlying protocol, but since a large majority of mail servers in-use are Linux based , 
we'll be focusing on enumerating users from "Sendmail", a popular Open-Source *NIX-based mail 
server

In the wild, you will mostly encounter Sendmail, Postfix, Exim or Microsoft Exchange. The following 
techniques can apply to all 

Similar to the user enumeration process for SMB users, as discussed previously, there are several 
ways to accomplish this task either using manual methods or using tools designed for the purpose 
of enumerating users from a mail server 

We will cover several verbs/methods we can use to enumerate users from SMTP here


The first task is to enumerate which options, "verbs" or "features" are enabled on an SMTP 
server, usually found on tcp/25; this can be accomplished with the "smtp-commands" nmap 
NSE script 

## nmap --script smtp-commands <targetIP> -p 25

We can also achieve the same results with a direct connection to port 25 using telnet or 
netcat by simply issuing a "help" followed by <Enter> command once connected via 

nc <targetIP> 25 

or 

telnet <targetIP> 25 

For our purposes, we're interested in the RCPT, VRFY and EXPN verbs. (All of which can be used to
enumerate users on the server)


Using "RCPT TO" (who we're sending the mail to, in this case, the user we're enumerating), we can
enumerate users via direct connection to the mail server with either telnet or netcat. We're going
to use telnet here. The series of commands is straightforward. First, we connect: 

telnet <targetIP> 25 

Secondly we issue the "HELO" verb with "tester.localdomain" for a domain name

We then tell the server who the mail will be from with the "MAIL FROM" verb
(Examples for these verbs shown in folder)

Once we've: 

1. Identified ourselves (HELO tester.localadmin) 
2. Set the MAIL FROM (MAIL FROM: tester@tester.localdomain)

We can then proceed with sequentially enumerating potential users from the system with the 
"RCPT TO: <user@domain.com>" command  (example shown in folder)


Valid users will return a status code of "250 2.1.5" while a "550 5.1.1" status code and 
"User Uknown" message denotes a non-existent user

Lastly, the "VRFY" request can also be used and is more common than the "EXPN" method. The same 
command line can be used with VRFY, and the results are similar to the EXPN output

again, Valid users will return a status code of "250 2.1.5" while a "550 5.1.1" status code and 
"User Uknown" message denotes a non-existent user 

(screenshot example in folder)



# smtp-user-enum

smtp-user-enum by pentestmonkey is a great tool that automates the user enum process for
SMTP. The previous notes gives is a good understanding of how this tool works and what
its doing under the hood, after all, understanding exactly what our tools are doing, is an 
important part of who we are as penetration testers

smtp-user-enum tests all three methods, RCPT, EXPN and VRFY that we've covered, against 
a list of users

Resources: 


# http://pentestmonkey.net/tools/user-enumeration/smtp-user-enum
# https://github.com/ShawnDEvans/smbmap
# https://github.com/insidetrust/statistically-likely-usernames
# https://cr.yp.to/smtp/mail.html 
# https://cr.yp.to/smtp/vrfy.html